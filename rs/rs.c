//////////////////////////////////////////////////////////////////////
//
// File: rs.c
// Author: Adam Janin
//         11/10/02
//
// See README for notes, especially on the stuff in tbgstatc.c.
//
// The weird thing about this code is that instead of reading data
// files, I generate C code containing the current trade and ship
// information. This is strange, unneccessary, and a result of the
// history of the code.
//
// Trade data is stored in tbgdata.c. Ship data is in shipdata.c.
//

#include <stdio.h>
#include <strings.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <unistd.h>
#include <math.h>
#include <libpq-fe.h>

#include "lists.h"

#ifdef DEBUG
#define GC_MALLOC malloc
#else
#include <gc.h>
#endif

#define NSTARS (129)
#define NRES (32)

//////////////////////////////////////////////////////////////////////
//
// Ship Globals
//

#include "shipdata.c"

//////////////////////////////////////////////////////////////////////
//
// Some other globals you might want to adjust
//

// Each turn, the prices tend towards the average price of the
// resource at the given colony. 
// 
// newprice = ar*curprice + (1-ar)*average.
//
// Values near one mean that prices tend to the average slowly.
// values near zero mean prices go quickly to their average.

#define AVERAGING_RATE (0.8)


// The algorithm tends to load up on whatever is nearby. To counter
// this, you can limit the number of pods loaded with a single
// resource during a turn.

#define MaxNPods (2)

// The price of a resource drops 35% every time it is sold at a
// colony, and all other colonies go up by 5%. This is too hard to
// model. Instead, we simply multiply the price a colony offers by
// this amount if you've visited the system before, regardless of
// whether you actually sold.

#define REVISIT_MULTIPLIER (0.8)


//////////////////////////////////////////////////////////////////////
//
// Types
//

typedef int MoneyType;
typedef char ResIndex;
typedef unsigned char StarIndex;


//////////////////////////////////////////////////////////////////////
//
// Stores info about buyers (e.g. colonies).
//

typedef struct {
  MoneyType price;
  MoneyType average;
  ResIndex res;
} BuyerType;

//////////////////////////////////////////////////////////////////////
//
// Stores info about sellers (e.g. factories)
//

typedef struct {
  MoneyType price;
  ResIndex res;
} SellerType;

//////////////////////////////////////////////////////////////////////
//
// Stores info about a pod.
//

typedef struct {
  char n;		// Current number loaded (capacity is always implicit)
  ResIndex res;		// Which resource.
} PodType;

//////////////////////////////////////////////////////////////////////
//
// A hypothesis consists of cash on hand, the location, and the pods
// of the ship. Note that there are MANY hyps, so this structures
// should be as small as possible.
//

typedef struct _HypType {
  MoneyType cash;
  StarIndex loc;
  PodType pod[NPODS];
  int bonus;
  struct _HypType* parent;
} HypType;

//////////////////////////////////////////////////////////////////////
//
// This file has all the static trade data.
// 


#include "tbgstatic.c"

//////////////////////////////////////////////////////////////////////
//
// Prototypes
//

void OpenLog();
void CloseLog();
void logit(char*, ...);
int BeenTo(HypType*, int);
StarIndex StarNameToID(const char* star);
ResIndex ResNameToID(const char* res);
MoneyType JumpCost(StarIndex src, StarIndex dest, int cargomass);
int GetMass(const HypType*);
int WarpFactor(int cargomass);
void InitializeLoad(int firstn, ...);
void PrintHyp(const HypType*);
StarIndex PrintOrders(HypType*);
HypType* NewHyp(const HypType*);
List* ExtendSell(List* hyps);
SList* ExtendBuy(List* hyps);
SList* ExtendJump(SList* hyps);
SList* ForwardTurn(SList* hyps);
void Sell(HypType*, int n, ResIndex res);
int ComputeValue(const HypType* hyp);
List* HistogramSort(List* ll, int newn);
int getint(const char*);
float getfloat(const char*);
void dbexit();
int SelectInt(char*, ...);
char* PSQL_Quote(char*);
void load_db();


//////////////////////////////////////////////////////////////////////
//
// Globals
//

HypType InitialHyp;

// Pruning lengths. 
// NHypsSell is the size of the list of hyps AFTER selling.
// NHypsBuy is the size of the list of hyps WHILE buying.
// NHypsJump is the size of the list of hyps WHILE jumping.
// NHypsReport is the number of hyps that are printed at the end.

int NHypsSell = 200000;
int NHypsBuy  = 200000;
int NHypsJump = 200000;
int NHypsReport = 3000;

int Turn = 0;	// Turn number

// Capacity of ship's pods. See shipdata.c (generated by genplayer.pl).
short PodCapacity[NPODS] = {
  POD_CAPACITY
};

// When computing the "value" of a ship for pruning or sorting, I add
// the cash, plus some multiple of the value of the cargo, where the
// base is the cost to buy it from a factory. 

float* CargoWeight;

// Number of turns to look forward

int NTurns = DEFAULT_NTURNS;

// Report to stderr as well as logfile
int Verbose = 0;

// Store the database connection
PGconn *DatabaseConnection;

// StarIndex of Olympus
StarIndex OlympusIndex;

// Name of log file
#define LOG_FILENAME "/Path/to/rs/log"
FILE* LogFH;

//////////////////////////////////////////////////////////////////////
//
// Misc defines
//

#define MIN(a_, b_) ((a_) < (b_) ? (a_) : (b_))
#define MAX(a_, b_) ((a_) > (b_) ? (a_) : (b_))

void usage() {
  fprintf(stderr, "Usage: tbg -n nturns -s sellhyps -b buyhyps -j jumphyps value0 value1 ...\n");
  fprintf(stderr, "  n              - Number of turns to run [%d]\n", NTurns);
  fprintf(stderr, "  sellhyps       - list size BEFORE selling [%d]\n", NHypsSell);
  fprintf(stderr, "  buyhyps        - list size BEFORE buying [%d]\n", NHypsBuy);
  fprintf(stderr, "  jumphyps       - list size BEFORE jumping [%d]\n", NHypsJump);
  fprintf(stderr, "  val0 val1 ...  - Weight of cargo when computing values.\n\n");
  fprintf(stderr, "  ValN defaults to ValN-1. Val0 is 1.0 if not specified\n\n");
  exit(-1);
}


//////////////////////////////////////////////////////////////////////
//
// Main
//

int main(int argc, char** argv) {
  SList *hyps;
  int i;
  extern char *optarg;
  extern int optind;
  int c;
  float defaultvw;
  int si, bi, ji;
  List* ll;
  HypType* hyp;
  char* tok;
  char* cargoweightstr;
  //  short* jumplist;

  OpenLog();
  while ((c = getopt(argc, argv, "n:s:b:j:r:hv")) != EOF) {
    switch (c) {
    case 'n':
      NTurns = getint(optarg);
      break;
    case 's':
      NHypsSell = getint(optarg);
      break;
    case 'b':
      NHypsBuy = getint(optarg);
      break;
    case 'j':
      NHypsJump = getint(optarg);
      break;
    case 'r':
      NHypsReport = getint(optarg);
      break;
    case 'v':
      Verbose = !Verbose;
      break;
    case 'h':
    case '?':
    default:
      usage();
    }
  }

  CargoWeight = GC_MALLOC(sizeof(float)*NTurns);
  defaultvw = 2.0;
  i = 0;
  cargoweightstr = GC_MALLOC(strlen(DEFAULT_CARGO_WEIGHT)+1);
  strcpy(cargoweightstr, DEFAULT_CARGO_WEIGHT);
  for (tok = strtok(cargoweightstr, " "); tok; tok = strtok(NULL, " ")) {
    defaultvw = getfloat(tok);
    CargoWeight[i++] = defaultvw;
  }
  for (; i < NTurns; i++) {
    CargoWeight[i] = defaultvw;
  }

  OlympusIndex = StarNameToID("Olympus");

  logit("Loading data");
  init_buyers();
  load_db();
  InitializeLoad(INITIAL_LOAD);

  InitialHyp.cash = INITIAL_ENERGY;
  InitialHyp.loc = StarNameToID(INITIAL_LOC);
  InitialHyp.bonus = 0;
  InitialHyp.parent = 0;

  hyps = NewSList(NHypsSell);
  AddToSList(&InitialHyp, ComputeValue(&InitialHyp), hyps);

  //PrintOrders(&InitialHyp);
  

  for (Turn = 0; Turn < NTurns; Turn++) {
    hyps = ForwardTurn(hyps);
  }

  // Print out the top NHypsReport hyps. Then print out the first
  // jumps.

  //  jumplist = GC_MALLOC(sizeof(short)*NSTARS);
  //  for (i = 0; i < NSTARS; i++) {
  //    jumplist[i] = -1;
  //  }

  i = NHypsReport;
  for (si = hyps->maxval - hyps->minval; si >= 0 && i > 0; si--) {
    ll = (List*) hyps->buf[si];
    if (ll) {
      for (bi = 0; bi < ll->n && i > 0; bi++, i--) {
	hyp = (HypType*) ll->buf[bi];
	printf("\n\nPath %d\n", NHypsReport - i+1);
	ji = PrintOrders(hyp);
	printf("\n\n");
	//	if (jumplist[ji] == -1) {
	//   jumplist[ji] = i;
	//}
      }
    }
  }
  /*  printf("First jumps:\n");
  for (i = 0; i < NSTARS; i++) {
    if (jumplist[i] != -1) {
      printf("%14s %3d\n", StarName[i], jumplist[i]);
    }
  }
  */

  CloseLog();
  return 0;
}  // main()


//////////////////////////////////////////////////////////////////////
//
// Given a star name, return its ID (index into the various arrays).
// This doesn't have to be fast, since it is only done once.
//

StarIndex StarNameToID(const char* star) {
  StarIndex i;
  
  for (i = 0; i < NSTARS; i++) {
    if (!strcasecmp(star, StarName[i])) {
      return i;
    }
  }
  fprintf(stderr, "Couldn't find star %s!\n", star);
  exit(-1);
}


//////////////////////////////////////////////////////////////////////
//
// Given a resource name, return its ID (index into the various arrays).
// This doesn't have to be fast, since it is only done once.
//

ResIndex ResNameToID(const char* res) {
  ResIndex i;
  
  for (i = 0; i < NRES; i++) {
    if (!strcasecmp(res, ResName[i])) {
      return i;
    }
  }
  fprintf(stderr, "Couldn't find resource %s.\n", res);
  exit(-1);
}

//////////////////////////////////////////////////////////////////////
//
// Cost to jump from star id i to star id j if you're carrying
// the specified amount of cargo.
//

MoneyType JumpCost(StarIndex i, StarIndex j, int cargomass) {
  int x0, y0, x1, y1;
  double c;
  if (CanStargate(i, j)) {
    return 0;
  }
  x0 = StarX[i];
  y0 = StarY[i];
  x1 = StarX[j];
  y1 = StarY[j];
  /*  return (((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0)) * 10) / WarpFactor(cargomass); */
  c = exp(4.0*sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0))/log(WarpFactor(cargomass)))/200.0;
  if (c > 10000.0) {
    return 10000;
  } else {
    return (MoneyType) c;
  }
}

//////////////////////////////////////////////////////////////////////
//
// Warp factor given specified cargo
//

int WarpFactor(int cargomass) {
  int warp;
  cargomass += EMPTY_MASS;
  warp = WARP_TECH * 100 / cargomass;
  if (ENG_SKILL > 2 * warp) {
    return 3 * warp;
  } else {
    return warp + ENG_SKILL;
  }
}

//////////////////////////////////////////////////////////////////////
//
// Usage: InitializeLoad(3, "Quad Trees", 0, "", 2, "Videos")
//
// Does almost no error checking!
//

void InitializeLoad(int firstn, ...) {
  int n;
  char* res;
  int i;
  va_list args;

  va_start(args, firstn);
  res = va_arg(args, char*);
  n = firstn;
  i = 0;
  for (;;) {
    InitialHyp.pod[i].n = n;
    if (n > 0) {
      InitialHyp.pod[i].res = ResNameToID(res);
    } else {
      InitialHyp.pod[i].res = -1;
    }
    i++;
    if (i >= NPODS) {
      break;
    }
    n = va_arg(args, int);
    res = va_arg(args, char*);
  }
  va_end(args);
}  // InitializeLoad()

//////////////////////////////////////////////////////////////////////
//
// Print just the current hypothesis, not the full path.
//
// Note: This is usually the END of a turn.
//

void PrintHyp(const HypType* hyp) {
  int i;
  printf("At %s with $%d + %d", StarName[hyp->loc], hyp->cash, hyp->bonus);
  for (i = 0; i < NPODS; i++) {
    if (hyp->pod[i].n > 0) {
      printf(", %d/%d %s", hyp->pod[i].n, PodCapacity[i], 
	     ResName[hyp->pod[i].res]);
    } else {
      if (hyp->pod[i].res != -1) {
	fprintf(stderr, "--- This should never happen!");
	exit(-1);
      }
      printf(", 0/%d", PodCapacity[i]);
    }
  }
  printf("\n");
} // PrintHyp()

//////////////////////////////////////////////////////////////////////
//
// Given a hyp, print the orders all the way to the root.
//
// Returns the index of the first jump.
//

StarIndex PrintOrders(HypType* hyp) {
  List* ll;
  HypType* h;
  int i;
  
  ll = NewList(10);
  
  for (h = hyp; h; h = h->parent) {
    AddToList(h, ll);
  }
  
  for (i = ll->n-1; i >= 0; i--) {
    PrintHyp(ll->buf[i]);
  }
  return ((HypType*)(ll->buf[ll->n-2]))->loc;
} // PrintOrders()  

//////////////////////////////////////////////////////////////////////
//
// Make a new hyp that's a copy of the current hyp
//

HypType* NewHyp(const HypType* hyp) {
  HypType* newhyp;
  
  newhyp = GC_MALLOC(sizeof(HypType));
  memcpy(newhyp, hyp, sizeof(HypType));
  return newhyp;
}

//////////////////////////////////////////////////////////////////////
//
//  Instead of beam pruning or the like, I keep the hyps on a sorted,
//  bounded list (SList, see lists.c). ExtendSell is an
//  exception. Instead of using a bounded list, I generate all
//  results, and then sort and truncate. As a result, ExtendSell can
//  generate a lot of garbage.
//

SList* ForwardTurn(SList* shyps) {
  int star, col;
  List* hyps;
  
  logit("   Start of turn %d.", Turn);

  logit("Extend sell");
  hyps = SListToList(shyps);
  hyps = ExtendSell(hyps);
  hyps = HistogramSort(hyps, NHypsSell);

  logit("Extend buy");
  shyps = ExtendBuy(hyps);
  logit("Best = %d, Worst = %d", shyps->maxval, shyps->minval);

  logit("Extend jump with %d elements", shyps->size);
  shyps = ExtendJump(shyps);

  logit("End of turn %d.", Turn);
  logit("Best = %d, Worst = %d", shyps->maxval, shyps->minval);

  logit("Adjusting prices.");

  for (star = 0; star < NSTARS; star++) {
    for (col = 0; col < StarToNBuyers[star]; col++) {
      StarToBuyers[star][col].price = 
	AVERAGING_RATE * StarToBuyers[star][col].price +
	(1-AVERAGING_RATE) * StarToBuyers[star][col].average;
    }
  }

  return shyps;
}

List* ExtendSell(List* hyps) {
  int p, i, n, h, hi, nhyps;
  int nsell;
  int cansell[NRES];
  int curpos;
  HypType *newhyp, *hyp;
  List* out;

  out = NewList(NHypsSell*2);

  nhyps = hyps->n;
  for (hi = 0; hi < nhyps; hi++) {
    hyp = hyps->buf[hi];
    curpos = out->n;
    
    newhyp = NewHyp(hyp);
    newhyp->parent = hyp;
    AddToList(newhyp, out);
    
    // Compute how many of EACH resource you can sell
    // min(# of resource, # colonies that buy resource)
    
    for (i = 0; i < NRES; i++) {
      cansell[i] = 0;
    }
    
    for (p = 0; p < NPODS; p++) {
      if (hyp->pod[p].n > 0) {
	cansell[hyp->pod[p].res] += hyp->pod[p].n;
      }
    }
    
    for (i = 0; i < NRES; i++) {
      if (cansell[i] > 0) {
	cansell[i] = MIN(cansell[i], StarResToNBuyers[hyp->loc][i]);
	if (cansell[i] > 0) {
	  n = out->n;
	  for (h = curpos; h < n; h++) {
	    for (nsell = 1; nsell <= cansell[i]; nsell++) {
	      newhyp = NewHyp(out->buf[h]);
	      Sell(newhyp, nsell, i);
	      AddToList(newhyp, out);
	    }
	  }
	}
      }
    }
  }
  return out;
}  // ExtendSell()

void Sell(HypType* hyp, int selln, ResIndex res) {
  int p, b;
  int n;
  int x;
  int best;
  int cash;

  // In each case, sell out the pods, then compute the price.

  n = 0;
  
  for (p = 0; p < NPODS; p++) {
    if (hyp->pod[p].n > 0 && hyp->pod[p].res == res) {
      x = MIN(hyp->pod[p].n, selln);
      hyp->pod[p].n -= x;
      if (hyp->pod[p].n <= 0) {
	hyp->pod[p].res = -1;
      }
      n += x;
      if (n >= selln) {
	break;
      }
    }
  }

  if (n < selln) {
    fprintf(stderr, "--- Failed to sell %s, n=%d selln=%d\n", ResName[res], n, selln);
    PrintHyp(hyp);
    exit(-1);
  }

  // Now compute the amount of money we get, assuming you always sell
  // to the best price first. General case is to sort prices, and sum
  // the first selln of them. But I'm lazy, so I just do special cases.

  // Case 1: Number to sell is equal to number available.
  // Just sell all, and price is sum

  if (selln == StarResToNBuyers[hyp->loc][res]) {
    cash = 0;
    for (b = 0; b < StarToNBuyers[hyp->loc]; b++) {
      if (StarToBuyers[hyp->loc][b].res == res) {
	cash += StarToBuyers[hyp->loc][b].price;
      }
    }

 // Case 2: Number to sell is one. Price is best price

  } else if (selln == 1) {
    best = 0;
    for (b = 0; b < StarToNBuyers[hyp->loc]; b++) {
      if (StarToBuyers[hyp->loc][b].res == res) {
	if (StarToBuyers[hyp->loc][b].price > best) {
	  best = StarToBuyers[hyp->loc][b].price;
	}
      }
    }
    cash = best;
  } else {
    // This should never happen, since the most any system buys is 2.
    fprintf(stderr, "--- This case isn't handled yet!\n");
    exit(-1);
  }

  // Figure out if we've been here before. If so, set the multiplier to
  // REVISIT_MULTIPLIER. Otherwise, set it to 1.

  if (BeenTo(hyp, hyp->loc)) {
    hyp->cash += REVISIT_MULTIPLIER * cash;
  } else {
    hyp->cash += cash;
  }




}  // Sell()



//////////////////////////////////////////////////////////////////////
//
// Extend by jumping to every system.
// Add the bonus score, if any.
//
// Need to do a beam here, I think...
//

SList* ExtendJump(SList* hyps) {
  int i;
  int cost;
  int si, bi;
  HypType *hyp, *newhyp;
  SList* outslist;
  List* ll;

  outslist = NewSList(NHypsJump);
  
  for (si = 0; si < hyps->maxval - hyps->minval + 1; si++) {
    ll = (List*) hyps->buf[si];
    if (ll == 0) {
      continue;
    }
    for (bi = 0; bi < ll->n; bi++) {
      hyp = (HypType*) ll->buf[bi];
      for (i = 0; i < NSTARS; i++) {
	if (!OLYMPIAN && i == OlympusIndex) {
	  continue;
	}
	cost = JumpCost(hyp->loc, i, GetMass(hyp));
	if (cost < hyp->cash &&
	    (MAX_JUMP_COST < 0 || cost <= MAX_JUMP_COST)) {
	  newhyp = NewHyp(hyp);
	  newhyp->loc = i;
	  newhyp->cash -= cost;
	  if (!BeenTo(newhyp, i)) {
	    newhyp->bonus += SystemScore[i];
	  }
	  AddToSList(newhyp, ComputeValue(newhyp), outslist);
	}
      }
    }
  }
  return outslist;
} // ExtendJump

// Return 1 if we've been to this star before
int BeenTo(HypType* hyp, int stari) {
  while (hyp = hyp->parent) {
    if (hyp->loc == stari) {
      return 1;
    }
  }
  return 0;
}

SList* ExtendBuy(List* hyps) {
  ResIndex res;
  MoneyType price;
  int buyn;
  int maxbuyn;
  int p, i, n;
  int nhyps;
  int nleft;
  int npods;
  int turncost;
  HypType *hyp, *newhyp;
  SList* outslist;

  outslist = NewSList(NHypsBuy);

  nhyps = hyps->n;
  for (i = 0; i < nhyps; i++) {
    hyp = (HypType*) hyps->buf[i];
    AddToSList(hyp, ComputeValue(hyp), outslist);
  
    res = StarToSellers[hyp->loc].res;
    if (res == -1 || (!CONTRABAND && IsContraband[res])) {
      continue;
    }
    price = StarToSellers[hyp->loc].price;

    // If you already hold some, and the pod isn't full, you can fill
    // it. If the pod is empty, you can buy as many as you want.

    maxbuyn = hyp->cash / price;
    for (buyn = 1; buyn <= maxbuyn; buyn++) {
      turncost = 0;
      nleft = buyn;
      newhyp = NewHyp(hyp);
      npods = 0;
      for (p = 0; nleft > 0 && p < NPODS; p++) {
	if (newhyp->pod[p].n == 0 || 
	    (newhyp->pod[p].res == res && newhyp->pod[p].n < PodCapacity[p])) {
	  n = MIN(nleft, PodCapacity[p] - newhyp->pod[p].n);
	  newhyp->pod[p].res = res;
	  newhyp->pod[p].n += n;
	  turncost += price*n;
	  newhyp->cash -= price * n;
	  nleft -= n;
	  npods++;
	  if (npods > MaxNPods || (MAX_PURCHASE >= 0 && turncost > MAX_PURCHASE)) {
	    break;
	  }
	}
      }
      if (nleft == 0 && npods <= MaxNPods && 
	  (MAX_PURCHASE < 0 || turncost <= MAX_PURCHASE)) {
	AddToSList(newhyp, ComputeValue(newhyp), outslist);
      } else {
	break;
      }
    }
  }
  return outslist;
} // ExtendBuy

int GetMass(const HypType* hyp) {
  int mass, p;
  mass = 0;
  for (p = 0; p < NPODS; p++) {
    mass += hyp->pod[p].n;
  }
  return mass;
}


int ComputeValue(const HypType* hyp) {
  int tot;
  int p;
  
  tot = 0;
  for (p = 0; p < NPODS; p++) {
    tot += hyp->pod[p].n * ResToSalePrice[hyp->pod[p].res];
  }
  return hyp->bonus + hyp->cash + CargoWeight[Turn] * tot;
}

//////////////////////////////////////////////////////////////////////
//
// Return a new list with (approximately) the best newn elements from
// the old list.
//
// Computes a histogram of all elements, then takes elements until
// newn are found.
//

List* HistogramSort(List* ll, int newn) {
  List* hist;
  int i, j;
  HypType* hyp;
  int value;
  List* bin;
  List* res;
  int initsize;
  int best, worst, range;
  int targetnewn = newn;

  logit("Sorting %d elements...", ll->n);

  best = ComputeValue((HypType*) ll->buf[0]);
  worst = best;
  for (i = 1; i < ll->n; i++) {
    value = ComputeValue((HypType*) ll->buf[i]);
    if (value > best) {
      best = value;
    }
    if (value < worst) {
      worst = value;
    }
  }

  range = best-worst;
  if (range <= 0) {
    range = 1;
  }
  hist = NewList(range+1);
  initsize = 10*ll->n / range;		// waste memory for speed
  for (i = 0; i <= range; i++) {
    AddToList(NewList(initsize), hist);
  }
  res = NewList(newn);
  
  for (i = 0; i < ll->n; i++) {
    hyp = (HypType*) ll->buf[i];
    value = ComputeValue(hyp);
    AddToList(hyp, (List*) hist->buf[value-worst]);
  }
  for (i = range; i >= 0; i--) {
    bin = (List*) hist->buf[i];
    for (j = 0; j < bin->n; j++) {
      AddToList(bin->buf[j], res);
      newn--;
      if (newn <= 0) {
	break;
      }
    }
    if (newn <= 0) {
      break;
    }
  }
  res->n = MIN(res->n, targetnewn);
  ClearUnusedList(res);
  worst = ComputeValue((HypType*) res->buf[res->n-1]);
  best = ComputeValue((HypType*) res->buf[0]);
  logit("Done sorting. %d elements\nBest = %d, worst = %d.", res->n, best, worst);
  return res;
}  // HistogramSort

float getfloat(const char* str) {
  float f;
  if (sscanf(str, "%f", &f) != 1) {
    fprintf(stderr, "Couldn't get float\n");
    exit(-1);
  }
  return f;
}

int getint(const char* str) {
  int i;
  if (sscanf(str, "%d", &i) != 1) {
    fprintf(stderr, "Couldn't get int\n");
    exit(-1);
  }
  return i;
}

//////////////////////////////////////////////////////////////////////
//
// Open a connection to the database, and load buyer price information.
//

void load_db() {
  int stari, buyeri, turn;
  char *qstarname, *qresname;

  DatabaseConnection = PQconnectdb("dbname = dow user = USERNAME password = PASSWORD");
  if (PQstatus(DatabaseConnection) == CONNECTION_BAD) {
    fprintf(stderr, "Connection to database failed.\n");
    fprintf(stderr, "%s", PQerrorMessage(DatabaseConnection));
    dbexit();
  }
  
  for (stari = 0; stari < NSTARS; stari++) {
    qstarname = PSQL_Quote(StarName[stari]);
    if (StarToNBuyers[stari] > 0) {
      turn = SelectInt("select max(turn) from trade where system='%s';", 
		       qstarname);
      for (buyeri = 0; buyeri < StarToNBuyers[stari]; buyeri++) {
	qresname = PSQL_Quote(ResName[StarToBuyers[stari][buyeri].res]);
	StarToBuyers[stari][buyeri].price = 
	  SelectInt("select avg(price) from trade where system='%s' and resource='%s' and turn=%d;",
		    qstarname, qresname, turn);
	StarToBuyers[stari][buyeri].average =
	  SelectInt("select avg(price) from trade where system='%s' and resource='%s';",
		    qstarname, qresname);		    
      }
    }
  }
  PQfinish(DatabaseConnection);
}

char* PSQL_Quote(char* s) {
  char* ret;
  ret = GC_MALLOC(2*strlen(s)+1);
  PQescapeString(ret, s, strlen(s));
  return ret;
}

int SelectInt(char* q, ...) {
  PGresult *res;
  int ret;
  char* resval;
  char qbuf[1000];
  va_list args;
  va_start(args, q);
  vsprintf(qbuf, q, args);
  va_end(args);

  res = PQexec(DatabaseConnection, qbuf);
  if (PQresultStatus(res) != PGRES_TUPLES_OK) {
    fprintf(stderr, "Query '%s' failed\n%s\n", qbuf, PQresultErrorMessage(res));
    PQclear(res);
    dbexit();
  }
  resval = PQgetvalue(res, 0, 0);
  if (sscanf(resval, "%d", &ret) != 1) {
    fprintf(stderr, "Query '%s' did not return an integer ('%s')\n",
	    qbuf, resval);
    PQclear(res);
    dbexit();
  }
  PQclear(res);
  return ret;
}

void dbexit() {
  PQfinish(DatabaseConnection);
  exit(1);
}

void OpenLog() {
  LogFH = fopen(LOG_FILENAME, "a");
  if (!LogFH) {
    fprintf(stderr, "Couldn't open log file!");
    exit(1);
  }
}

void CloseLog() {
  fclose(LogFH);
}

void logit(char* fmt, ...) {
  va_list args;
  va_start(args, fmt);
  vfprintf(LogFH, fmt, args);
  fprintf(LogFH, "\n");
  fflush(LogFH);
  if (Verbose) {
    vfprintf(stderr, fmt, args);
    fprintf(stderr, "\n");
    fflush(stderr);
  }
  va_end(args);
}
